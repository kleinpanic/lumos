#define _POSIX_C_SOURCE 200809L
#define _GNU_SOURCE

#include "udev_setup.h"
#include "brightness.h"        // for BACKLIGHT_BASE_PATH

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/stat.h>
#include <errno.h>
#include <dirent.h>
#include <limits.h>
#include <sys/utsname.h>
#include <grp.h>
#include <sys/types.h>

/* Paths we check/create */
#define UDEV_RULE_ETC   "/etc/udev/rules.d/90-lumos.rules"
#define UDEV_RULE_LIB   "/lib/udev/rules.d/90-lumos.rules"

/* Are we running as root? */
static int is_root(void) {
    return geteuid() == 0;
}

/* Does this path exist? */
static int file_exists(const char *path) {
    return access(path, F_OK) == 0;
}

/* Read PRETTY_NAME from /etc/os-release, fallback to uname() */
static char *get_os_pretty_name(void) {
    FILE *f = fopen("/etc/os-release", "r");
    char *name = NULL;
    if (f) {
        char line[256];
        while (fgets(line, sizeof(line), f)) {
            if (strncmp(line, "PRETTY_NAME=", 12) == 0) {
                char *val = strchr(line, '=') + 1;
                /* strip quotes and newline */
                size_t len = strlen(val);
                if (val[0] == '"' && val[len-2] == '"') {
                    val[len-2] = '\0';
                    val++;
                }
                name = strdup(val);
                break;
            }
        }
        fclose(f);
    }
    if (!name) {
        struct utsname uts;
        if (uname(&uts) == 0) {
            asprintf(&name, "%s %s", uts.sysname, uts.release);
        }
    }
    return name ? name : strdup("Unknown OS");
}

/* List all directory names under base_path (skips dotfiles) */
static char **list_sysfs_entries(const char *base_path, int *out_count) {
    DIR *d = opendir(base_path);
    if (!d) {
        *out_count = 0;
        return NULL;
    }
    char **list = NULL;
    int cap = 0, n = 0;
    struct dirent *ent;
    while ((ent = readdir(d)) != NULL) {
        if (ent->d_name[0] == '.') continue;
        if (n >= cap) {
            cap = cap ? cap * 2 : 8;
            list = realloc(list, cap * sizeof(*list));
        }
        list[n++] = strdup(ent->d_name);
    }
    closedir(d);
    *out_count = n;
    return list;
}

/* Write the single udev rules file */
static int write_rules_file(const char *rule_path, int include_leds) {
    FILE *f = fopen(rule_path, "w");
    if (!f) {
        fprintf(stderr, "Error: cannot open %s for writing: %s\n",
                rule_path, strerror(errno));
        return -1;
    }
    /* Set mode 0644 */
    if (fchmod(fileno(f), S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH) < 0) {
        fprintf(stderr, "Warning: failed to set permissions on %s: %s\n",
                rule_path, strerror(errno));
    }

    fprintf(f,
        "# 90-lumos.rules - auto-generated by lumos --setup\n"
        "# Grants Member of group \"video\" write access to brightness file\n"
    );

    /* backlight rule */
    fprintf(f,
        "SUBSYSTEM==\"backlight\", ACTION==\"add\", GROUP=\"video\", MODE=\"0664\"\n"
    );

    /* optional LEDs */
    if (include_leds) {
        fprintf(f,
            "SUBSYSTEM==\"leds\",      ACTION==\"add\", GROUP=\"video\", MODE=\"0664\"\n"
        );
    }

    fclose(f);
    return 0;
}

/* Reload and trigger udev so the rules take effect immediately */
static int reload_udev_rules(void) {
    int r1 = system("udevadm control --reload-rules");
    int r2 = system("udevadm trigger");
    return (r1 != 0 || r2 != 0) ? -1 : 0;
}

/* Entry point */
void run_udev_setup(void) {
    if (!is_root()) {
        fprintf(stderr,
            "Error: 'lumos --setup' must be run as root. Try: sudo lumos --setup\n");
        exit(EXIT_FAILURE);
    }

    /* Bail if someoneâ€™s already dropped a rule in /etc or /lib */
    if (file_exists(UDEV_RULE_ETC) || file_exists(UDEV_RULE_LIB)) {
        const char *existing = file_exists(UDEV_RULE_ETC)
                             ? UDEV_RULE_ETC : UDEV_RULE_LIB;
        printf("Udev rule already exists at %s; nothing to do.\n", existing);
        exit(EXIT_SUCCESS);
    }

    /* Discover & keep track for summary */
    int nb = 0, nl = 0;
    char **backs = list_sysfs_entries(BACKLIGHT_BASE_PATH, &nb);
    char **leds  = NULL;
    if (access("/sys/class/leds", R_OK|X_OK) == 0) {
        leds = list_sysfs_entries("/sys/class/leds", &nl);
    }

    /* 1) Write out the rule file */
    if (write_rules_file(UDEV_RULE_ETC, nl > 0) != 0) {
        fprintf(stderr, "Failed to write udev rule; aborted.\n");
        exit(EXIT_FAILURE);
    }

    /* 2) Reload all rules */
    printf("Reloading udev rules... ");
    if (reload_udev_rules() == 0) {
        printf("done.\n");
    } else {
        fprintf(stderr,
            "Failed to reload udev rules automatically.\n"
            "You may need:\n"
            "  sudo udevadm control --reload-rules && sudo udevadm trigger\n");
    }

    /* 3) Retrigger only backlight & leds so new rules apply */
    system("udevadm trigger --subsystem-match=backlight --action=add");
    system("udevadm trigger --subsystem-match=leds      --action=add");

    /* 4) One-time pass to fix existing files */
    struct group *g = getgrnam("video");
    gid_t        vid = g ? g->gr_gid : (gid_t)-1;
    int          fixed = 0;
    char         path[PATH_MAX];
    struct dirent *ent;
    DIR *d;

    /* Backlight */
    d = opendir(BACKLIGHT_BASE_PATH);
    if (d) {
        while ((ent = readdir(d)) != NULL) {
            if (ent->d_name[0] == '.') continue;
            snprintf(path, sizeof(path),
                     "%s/%s/brightness",
                     BACKLIGHT_BASE_PATH,
                     ent->d_name);
            if (chmod(path, 0664) == 0) {
                if (vid != (gid_t)-1)
                    chown(path, -1, vid);
                fixed++;
            }
        }
        closedir(d);
    }

    /* LEDs */
    d = opendir("/sys/class/leds");
    if (d) {
        while ((ent = readdir(d)) != NULL) {
            if (ent->d_name[0] == '.') continue;
            snprintf(path, sizeof(path),
                     "/sys/class/leds/%s/brightness",
                     ent->d_name);
            if (chmod(path, 0664) == 0) {
                if (vid != (gid_t)-1)
                    chown(path, -1, vid);
                fixed++;
            }
        }
        closedir(d);
    }

    /* 5) Final summary */
    char *osname = get_os_pretty_name();
    printf("\n=== lumos --setup Summary ===\n");
    printf(" OS: %s\n", osname);
    free(osname);

    printf(" Backlight interfaces (%d):", nb);
    for (int i = 0; i < nb; i++) {
        printf(" %s", backs[i]);
        free(backs[i]);
    }
    printf("\n");

    if (nl > 0) {
        printf(" LED interfaces (%d):", nl);
        for (int i = 0; i < nl; i++) {
            printf(" %s", leds[i]);
            free(leds[i]);
        }
        printf("\n");
    }

    printf(" Udev rule installed at: %s\n", UDEV_RULE_ETC);
    printf(" Existing brightness files fixed: %d\n", fixed);
    printf(" You can inspect or tweak the rule file as needed.\n");
    printf("Done.\n");

    exit(EXIT_SUCCESS);
}
